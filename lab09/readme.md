
# Лабораторная работа №9: Оптимизация Docker-образов

## Цель работы
Познакомиться с методами оптимизации Docker-образов и научиться уменьшать их размер.

## Задание
Сравнить влияние следующих приёмов на размер образа:
1. Удаление временных файлов и неиспользуемых зависимостей  
2. Уменьшение количества слоёв  
3. Использование минимального базового образа  
4. Перепаковка (flatten) образа  
5. Применение всех методов вместе  

## Описание выполнения работы

1. **Исходный образ (`mynginx:raw`)**  
   - Dockerfile.raw (на базе `ubuntu:latest`)
   - Сборка:  
     ```bash
     docker image build -t mynginx:raw -f Dockerfile.raw .
     ```  
   - Размер: `164 MB`
   В данном случае никаких средств оптимизации контейнера не применялось.

2. **Удаление кэша и временных файлов (`mynginx:clean`)**  
   - Dockerfile.clean: добавлен 
   ```yml
    RUN apt-get update && apt-get upgrade -y
    RUN apt-get install -y nginx
    RUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
   ``` 
   в отдельном слое  
   - Сборка:  
     ```bash
     docker image build -t mynginx:clean -f Dockerfile.clean .
     ```  
   - Размер: `164 MB` (не изменился)

   Устанавливая приложения через пакетный менеджер, он оставляет кеш, временные файлы, списки пакетов, логи и т.д.
   при сборке каждая инструкция пишет данные в новый слой, при этом предыдущий слой остается read-only, достигается это путем использования UNION FILE SYSTEM, OverlayFS
   Каждый слой по сути это версия контейнера на этапе сборки, со свой файловой системой и данными их можно запускать как отдельный контейнер. 
   Я предлагаю провести аналогию с коммитами по одной ветке гита.

   Оптимизация в итоге не сработала потому что очистка кеша и т.д. произошла в верхнем слое по отношению к слою где данные были установлены, а они как я уже выше отметил имеют флаг readonly, и удалить их таким способом нельзя.


3. **Меньше слоёв (`mynginx:few`)**  
   - Dockerfile.few: объединены все `RUN` в один слой  
   ```yml
   RUN apt-get update && apt-get upgrade -y && \
    apt-get install -y nginx && \
    apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
   ```
   - Сборка:  
     ```bash
     docker image build -t mynginx:few -f Dockerfile.few .
     ```  
   - Размер: `115 MB`

  В данном случае установка и очистка произошла внутри одной команды RUN, следовательно внутри одного слоя и кеш был успешно очищен.

4. **Минимальный базовый образ (`mynginx:alpine`)**  
   - Dockerfile.alpine на базе `alpine:latest`, установка через `apk`  
   - Сборка:  
     ```bash
     docker image build -t mynginx:alpine -f Dockerfile.alpine .
     ```  
   - Размер: `32.6 MB`

   `Alpine` это легковесный дистрибутив GNU/Linux, использует легковесные пакеты для меньшего размера и быстродействия, однако может быть непривычен в настройках. Изначально разрабатывался как дистрибутив для встроенных систем (роутеры и тд.)
 
5. **Перепаковка исходного образа (`mynginx:repack`)**  
   - Команды:
     ```bash
     docker container create --name tmp mynginx:raw
     docker container export tmp | docker image import - mynginx:repack
     docker container rm tmp
     ```  
   - Размер: `155 MB`

   Перепаковка (flatten) — это экспорт контейнера в tar и импорт обратно в образ. В результате слои совмещаются в один слой, теряются метаданные и история изменений. Тем не менее содержимое всех слоев сохраняется.


6. **Все методы вместе (`mynginx:minx` → `mynginx:min`)**  
   - Dockerfile.min: на базе `alpine:latest`, единый `RUN` для установки и очистки, без кеша  
   - Сборка и перепаковка:
     ```bash
     docker image build -t mynginx:minx -f Dockerfile.min .
     docker container create --name tmp2 mynginx:minx
     docker container export tmp2 | docker image import - mynginx:min
     docker container rm tmp2
     ```  
   - Размеры:  

| REPOSITORY | TAG    | IMAGE ID       | CREATED           | SIZE   |
|------------|--------|----------------|-------------------|--------|
| myngin     | min    | 8caeec1cab60   | 21 seconds ago    | 30.1MB |
| mynginx    | minx   | f7b5beef20c6   | 22 seconds ago    | 30.1MB |
| mynginx    | alpine | e97b01447c67   | 5 minutes ago     | 32.6MB |
| mynginx    | few    | 8cfaa5336d65   | 7 minutes ago     | 115MB  |
| mynginx    | repack | 1a46aec1fbcd   | 3 minutes ago     | 155MB  |
| mynginx    | clean  | b4593ffbc510   | 10 minutes ago    | 164MB  |
| mynginx    | raw    | 7cadbd559cf0   | 13 minutes ago    | 164MB  |



## Ответы на вопросы

1. **Наиболее эффективный метод**  
   Использование минимального базового образа (`alpine`) в сочетании с объединением команд в один слой дало наибольшее уменьшение — до ~30 MB.

2. **Почему очистка кеша в отдельном слое не уменьшает размер**  
   Потому что Docker создаёт новый слой При запуске команды с удалением файлов, но предыдущий слой, где они были скачаны, остаётся неизменным. Исторические данные по-прежнему занимают место.

3. **Что такое перепаковка образа**  
   Перепаковка (flatten) — это экспорт контейнера в tar и импорт обратно в образ. В результате все слои совмещаются в один, удаляется история изменений и ненужные метаданные, что часто уменьшает размер.

## Выводы
- Самый крутой результат даёт комбинирование всех методов: базовый `alpine`, единый слой и очистка кеша внутри этого слоя.  
- Перепаковка помогает «сплющить» историю, но без оптимизации слоёв и выбора лёгкого базового образа эффекта будет мало.  
- Всегда удаляйте кеш в том же слое, где вы его создали — иначе старые слои остаются «тяжёлыми».  
